# 分析

方法一：
	两重循环
	外层i遍历nums
	内层j前移寻找最左边的零所在位置
	交换
	时间复杂度：O(n^2)
	空间复杂度 ：O(1)

方法二：
	一重循环
	初始指针p指向index(0)
	循环i遍历nums
	遇到非0元素,将nums(i)元素直接覆盖nums(p)
	将index(p)向后移一位，直至遍历结束
	遍历结束后，将nums(p)以后元素全部赋0
	时间复杂度：O(n)
	空间复杂度：O(1)
	# 最快

方法三：
	一重循环
	初始指针p指向index(0)
	循环i遍历nums
	遇到非0元素,将nums(i)元素与nums(p)交换
	将index(p)向后移一位，直至遍历结束	
	时间复杂度：O(n)
	空间复杂度：O(1)

优化方法三：
	一重循环
	初始指针p指向index(0)
	循环i遍历nums
	遇到非0元素
	如果nums(i)==nums(p),将nums(i)元素与nums(p)交换
	将index(p)向后移一位，直至遍历结束	
	时间复杂度：O(n)
	空间复杂度：O(1)
	# 最快


# 程序见本文件	